-- =============================================================================
-- 3. DESARROLLO DEL CÓDIGO PL/SQL (VERSIÓN MEJORADA)
-- =============================================================================
-- Descripcion: Creación del paquete principal, funciones, procedimientos y triggers
--              con lógica de negocio de mayor complejidad.
-- Autor/a: [Tu Nombre Completo]
-- =============================================================================

CREATE OR REPLACE PACKAGE CINEPOLIS_PKG AS
    -- =========================================================================
    -- ERRORES PERSONALIZADOS
    -- =========================================================================
    e_asientos_insuficientes EXCEPTION;
    PRAGMA EXCEPTION_INIT(e_asientos_insuficientes, -20001);

    e_funcion_no_disponible EXCEPTION;
    PRAGMA EXCEPTION_INIT(e_funcion_no_disponible, -20002);

    e_cliente_no_encontrado EXCEPTION;
    PRAGMA EXCEPTION_INIT(e_cliente_no_encontrado, -20003);

    e_pelicula_sin_funciones EXCEPTION;
    PRAGMA EXCEPTION_INIT(e_pelicula_sin_funciones, -20006);
    
    -- =========================================================================
    -- TIPOS DE DATOS COMPUESTOS (RECORD y VARRAY)
    -- =========================================================================
    -- RECORD para devolver un reporte detallado de una película.
    TYPE rec_reporte_pelicula IS RECORD (
        titulo_pelicula peliculas.titulo%TYPE,
        total_espectadores NUMBER,
        ingresos_totales NUMBER,
        funcion_mas_exitosa_id funciones.funcion_id%TYPE
    );

    -- VARRAY para almacenar el historial de reservas de un cliente.
    TYPE varray_historial_reservas IS VARRAY(100) OF Reserva%ROWTYPE;

    -- =========================================================================
    -- FUNCIONES (Mínimo 5 - Ahora con mayor complejidad)
    -- =========================================================================

    -- 1. (Función de apoyo) Calcular la disponibilidad de asientos en una función.
    FUNCTION fn_disponibilidad_asientos(p_funcion_id IN NUMBER) RETURN NUMBER;

    -- 2. Obtener el historial completo de reservas de un cliente.
    --    (COMPLEJIDAD ALTA: Usa un cursor y un tipo de dato VARRAY).
    FUNCTION fn_obtener_historial_cliente(p_cliente_id IN NUMBER) RETURN varray_historial_reservas;

    -- 3. Verificar si un cliente cumple con todas las restricciones de una película (edad, etc.).
    --    (COMPLEJIDAD MEDIA: Lógica condicional anidada).
    FUNCTION fn_verificar_restricciones_pelicula(p_cliente_id IN NUMBER, p_funcion_id IN NUMBER) RETURN VARCHAR2;

    -- 4. Generar un reporte de rendimiento completo para una película.
    --    (COMPLEJIDAD ALTA: Usa subconsultas, agregaciones y un tipo de dato RECORD).
    FUNCTION fn_generar_reporte_pelicula(p_pelicula_id IN NUMBER) RETURN rec_reporte_pelicula;

    -- 5. Sugerir el mejor horario para una película basándose en la mayor disponibilidad.
    --    (COMPLEJIDAD ALTA: Usa un cursor, un bucle y lógica de comparación).
    FUNCTION fn_sugerir_mejor_horario(p_pelicula_id IN NUMBER) RETURN NUMBER;
    
    -- =========================================================================
    -- PROCEDIMIENTOS (Mínimo 3)
    -- =========================================================================

    -- 1. Registrar una nueva reserva (multitabla: Reserva, estadisticas_ocupacion)
    PROCEDURE sp_registrar_reserva(
        p_cliente_id IN NUMBER,
        p_funcion_id IN NUMBER,
        p_asientos_reservados IN NUMBER
    );

    -- 2. Generar reporte de ocupación por sala
    PROCEDURE sp_reporte_ocupacion_sala(p_sala_id IN NUMBER);

    -- 3. Procedimiento para registrar errores del sistema
    PROCEDURE sp_registrar_error(
        p_error_message IN VARCHAR2,
        p_contexto IN VARCHAR2
    );

    -- 4. Actualizar masivamente salarios de empleados por puesto
    PROCEDURE sp_actualizar_salarios_por_puesto(
        p_puesto IN VARCHAR2,
        p_porcentaje_aumento IN NUMBER
    );

END CINEPOLIS_PKG;
/

CREATE OR REPLACE PACKAGE BODY CINEPOLIS_PKG AS

    -- =========================================================================
    -- IMPLEMENTACIÓN DE FUNCIONES
    -- =========================================================================

    FUNCTION fn_disponibilidad_asientos(p_funcion_id IN NUMBER) RETURN NUMBER IS
        v_capacidad_sala NUMBER;
        v_asientos_reservados NUMBER;
        v_disponibilidad NUMBER;
    BEGIN
        SELECT s.capacidad INTO v_capacidad_sala
        FROM Salas s JOIN Funciones f ON s.sala_id = f.sala_id
        WHERE f.funcion_id = p_funcion_id;

        SELECT NVL(SUM(asientos_reservados), 0) INTO v_asientos_reservados
        FROM Reserva WHERE funcion_id = p_funcion_id;

        v_disponibilidad := v_capacidad_sala - v_asientos_reservados;
        RETURN v_disponibilidad;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN RAISE e_funcion_no_disponible;
        WHEN OTHERS THEN sp_registrar_error(SQLERRM, 'fn_disponibilidad_asientos'); RETURN -1;
    END fn_disponibilidad_asientos;

    FUNCTION fn_obtener_historial_cliente(p_cliente_id IN NUMBER) RETURN varray_historial_reservas IS
        v_historial varray_historial_reservas := varray_historial_reservas();
        CURSOR c_reservas IS SELECT * FROM Reserva WHERE cliente_id = p_cliente_id ORDER BY fecha_reserva DESC;
        v_count NUMBER := 0;
    BEGIN
        -- Verificar si el cliente existe
        SELECT COUNT(*) INTO v_count FROM Clientes WHERE cliente_id = p_cliente_id;
        IF v_count = 0 THEN RAISE e_cliente_no_encontrado; END IF;
        
        FOR rec IN c_reservas LOOP
            v_historial.EXTEND;
            v_historial(v_historial.LAST) := rec;
        END LOOP;
        
        RETURN v_historial;
    EXCEPTION
        WHEN e_cliente_no_encontrado THEN RAISE;
        WHEN OTHERS THEN sp_registrar_error(SQLERRM, 'fn_obtener_historial_cliente'); RETURN NULL;
    END fn_obtener_historial_cliente;

    FUNCTION fn_verificar_restricciones_pelicula(p_cliente_id IN NUMBER, p_funcion_id IN NUMBER) RETURN VARCHAR2 IS
        v_fecha_nacimiento DATE;
        v_clasificacion VARCHAR2(30);
        v_edad NUMBER;
    BEGIN
        SELECT fecha_nacimiento INTO v_fecha_nacimiento FROM Clientes WHERE cliente_id = p_cliente_id;
        SELECT p.clasificacion INTO v_clasificacion
        FROM Peliculas p JOIN Funciones f ON p.pelicula_id = f.pelicula_id
        WHERE f.funcion_id = p_funcion_id;
        
        v_edad := TRUNC(MONTHS_BETWEEN(SYSDATE, v_fecha_nacimiento) / 12);

        CASE v_clasificacion
            WHEN 'G' THEN RETURN 'APTO';
            WHEN 'PG' THEN RETURN 'APTO';
            WHEN 'PG-13' THEN IF v_edad >= 13 THEN RETURN 'APTO'; ELSE RETURN 'NO APTO POR EDAD'; END IF;
            WHEN 'R' THEN IF v_edad >= 18 THEN RETURN 'APTO'; ELSE RETURN 'NO APTO POR EDAD'; END IF;
            ELSE RETURN 'CLASIFICACION DESCONOCIDA';
        END CASE;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN RETURN 'DATOS INSUFICIENTES';
        WHEN OTHERS THEN sp_registrar_error(SQLERRM, 'fn_verificar_restricciones_pelicula'); RETURN 'ERROR EN VERIFICACION';
    END fn_verificar_restricciones_pelicula;

    FUNCTION fn_generar_reporte_pelicula(p_pelicula_id IN NUMBER) RETURN rec_reporte_pelicula IS
        v_reporte rec_reporte_pelicula;
    BEGIN
        SELECT p.titulo, 
               NVL(SUM(r.asientos_reservados), 0), 
               NVL(SUM(r.total_pago), 0)
        INTO v_reporte.titulo_pelicula, 
             v_reporte.total_espectadores, 
             v_reporte.ingresos_totales
        FROM Peliculas p
        LEFT JOIN Funciones f ON p.pelicula_id = f.pelicula_id
        LEFT JOIN Reserva r ON f.funcion_id = r.funcion_id
        WHERE p.pelicula_id = p_pelicula_id
        GROUP BY p.titulo;
        
        -- Encontrar la función más exitosa (con más asientos reservados)
        BEGIN
            SELECT f.funcion_id INTO v_reporte.funcion_mas_exitosa_id
            FROM Funciones f
            JOIN Reserva r ON f.funcion_id = r.funcion_id
            WHERE f.pelicula_id = p_pelicula_id
            GROUP BY f.funcion_id
            ORDER BY SUM(r.asientos_reservados) DESC
            FETCH FIRST 1 ROWS ONLY;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN v_reporte.funcion_mas_exitosa_id := NULL;
        END;

        RETURN v_reporte;
    EXCEPTION
        WHEN OTHERS THEN sp_registrar_error(SQLERRM, 'fn_generar_reporte_pelicula'); RETURN NULL;
    END fn_generar_reporte_pelicula;

    FUNCTION fn_sugerir_mejor_horario(p_pelicula_id IN NUMBER) RETURN NUMBER IS
        CURSOR c_funciones_futuras IS
            SELECT f.funcion_id
            FROM Funciones f
            WHERE f.pelicula_id = p_pelicula_id AND f.fecha >= TRUNC(SYSDATE)
            ORDER BY f.fecha, f.hora_inicio;
            
        v_mejor_funcion_id NUMBER := NULL;
        v_maxima_disponibilidad NUMBER := -1;
        v_disponibilidad_actual NUMBER;
        v_count_funciones NUMBER := 0;
    BEGIN
        SELECT COUNT(*) INTO v_count_funciones FROM Funciones WHERE pelicula_id = p_pelicula_id AND fecha >= TRUNC(SYSDATE);
        IF v_count_funciones = 0 THEN RAISE e_pelicula_sin_funciones; END IF;

        FOR reg IN c_funciones_futuras LOOP
            v_disponibilidad_actual := fn_disponibilidad_asientos(reg.funcion_id);
            IF v_disponibilidad_actual > v_maxima_disponibilidad THEN
                v_maxima_disponibilidad := v_disponibilidad_actual;
                v_mejor_funcion_id := reg.funcion_id;
            END IF;
        END LOOP;
        
        RETURN v_mejor_funcion_id;
    EXCEPTION
        WHEN e_pelicula_sin_funciones THEN RAISE;
        WHEN OTHERS THEN sp_registrar_error(SQLERRM, 'fn_sugerir_mejor_horario'); RETURN NULL;
    END fn_sugerir_mejor_horario;

    -- =========================================================================
    -- IMPLEMENTACIÓN DE PROCEDIMIENTOS (Ajustado para usar la nueva función)
    -- =========================================================================
    PROCEDURE sp_registrar_reserva(
        p_cliente_id IN NUMBER,
        p_funcion_id IN NUMBER,
        p_asientos_reservados IN NUMBER
    ) IS
        v_disponibilidad NUMBER;
        v_total_pago NUMBER;
        v_reserva_id NUMBER;
        v_estado_cliente VARCHAR2(100);
        v_precio_unitario CONSTANT NUMBER := 5000;
    BEGIN
        -- Validar disponibilidad de asientos
        v_disponibilidad := fn_disponibilidad_asientos(p_funcion_id);
        IF v_disponibilidad < p_asientos_reservados THEN RAISE e_asientos_insuficientes; END IF;

        -- Validar restricciones de la película para el cliente
        v_estado_cliente := fn_verificar_restricciones_pelicula(p_cliente_id, p_funcion_id);
        IF v_estado_cliente != 'APTO' THEN
            RAISE_APPLICATION_ERROR(-20004, 'El cliente no es apto para esta función: ' || v_estado_cliente);
        END IF;
        
        -- Calcular total a pagar
        v_total_pago := p_asientos_reservados * v_precio_unitario;

        -- Insertar en Reserva
        SELECT NVL(MAX(reserva_id), 0) + 1 INTO v_reserva_id FROM Reserva;
        INSERT INTO Reserva (reserva_id, cliente_id, funcion_id, asientos_reservados, fecha_reserva, total_pago)
        VALUES (v_reserva_id, p_cliente_id, p_funcion_id, p_asientos_reservados, SYSDATE, v_total_pago);

        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Reserva registrada exitosamente con ID: ' || v_reserva_id);

    EXCEPTION
        WHEN e_asientos_insuficientes THEN ROLLBACK; sp_registrar_error('Error: No hay suficientes asientos disponibles.', 'sp_registrar_reserva'); DBMS_OUTPUT.PUT_LINE('Error: No hay suficientes asientos disponibles.');
        WHEN e_funcion_no_disponible THEN ROLLBACK; sp_registrar_error('Error: La función especificada no existe.', 'sp_registrar_reserva'); DBMS_OUTPUT.PUT_LINE('Error: La función especificada no existe.');
        WHEN OTHERS THEN ROLLBACK; sp_registrar_error(SQLERRM, 'sp_registrar_reserva'); DBMS_OUTPUT.PUT_LINE('Ha ocurrido un error inesperado: ' || SQLERRM);
    END sp_registrar_reserva;

    -- (El resto de procedimientos y el cuerpo del paquete se mantienen igual)
    PROCEDURE sp_reporte_ocupacion_sala(p_sala_id IN NUMBER) IS
        CURSOR c_funciones_sala IS
            SELECT f.funcion_id, p.titulo, f.fecha, f.hora_inicio, s.capacidad
            FROM Funciones f
            JOIN Peliculas p ON f.pelicula_id = p.pelicula_id
            JOIN Salas s ON f.sala_id = s.sala_id
            WHERE f.sala_id = p_sala_id
            ORDER BY f.fecha;
        
        v_asientos_ocupados NUMBER;
        v_porcentaje_ocupacion NUMBER;
    BEGIN
        DBMS_OUTPUT.PUT_LINE('--- Reporte de Ocupación para la Sala ' || p_sala_id || ' ---');
        FOR reg IN c_funciones_sala LOOP
            SELECT NVL(SUM(asientos_reservados), 0) INTO v_asientos_ocupados
            FROM Reserva WHERE funcion_id = reg.funcion_id;
            
            v_porcentaje_ocupacion := (v_asientos_ocupados / reg.capacidad) * 100;

            DBMS_OUTPUT.PUT_LINE('Función ID ' || reg.funcion_id || ': ' || reg.titulo || 
                               ' (' || TO_CHAR(reg.fecha, 'DD-MON-YYYY') || ' ' || reg.hora_inicio || ') - ' ||
                               'Ocupados: ' || v_asientos_ocupados || '/' || reg.capacidad ||
                               ' (' || TO_CHAR(v_porcentaje_ocupacion, '990.99') || '%)');
        END LOOP;
        DBMS_OUTPUT.PUT_LINE('---------------------------------------------');
    EXCEPTION
        WHEN OTHERS THEN sp_registrar_error(SQLERRM, 'sp_reporte_ocupacion_sala'); DBMS_OUTPUT.PUT_LINE('Error al generar el reporte.');
    END sp_reporte_ocupacion_sala;

    PROCEDURE sp_registrar_error(p_error_message IN VARCHAR2, p_contexto IN VARCHAR2) IS
        PRAGMA AUTONOMOUS_TRANSACTION;
    BEGIN
        INSERT INTO error_log (error_message, contexto) VALUES (SUBSTR(p_error_message, 1, 4000), p_contexto);
        COMMIT;
    END sp_registrar_error;
    
    PROCEDURE sp_actualizar_salarios_por_puesto(p_puesto IN VARCHAR2, p_porcentaje_aumento IN NUMBER) IS
        CURSOR c_empleados IS SELECT empleado_id, salario FROM Empleados WHERE puesto = p_puesto FOR UPDATE OF salario;
    BEGIN
        IF p_porcentaje_aumento <= 0 THEN RAISE_APPLICATION_ERROR(-20005, 'El porcentaje de aumento debe ser positivo.'); END IF;
        FOR emp IN c_empleados LOOP
            UPDATE Empleados SET salario = emp.salario * (1 + p_porcentaje_aumento / 100) WHERE CURRENT OF c_empleados;
        END LOOP;
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('Salarios actualizados correctamente para el puesto: ' || p_puesto);
    EXCEPTION
        WHEN OTHERS THEN ROLLBACK; sp_registrar_error(SQLERRM, 'sp_actualizar_salarios_por_puesto'); DBMS_OUTPUT.PUT_LINE('Error al actualizar salarios.');
    END sp_actualizar_salarios_por_puesto;

END CINEPOLIS_PKG;
/

-- Los triggers se mantienen exactamente igual que en la versión anterior.
-- No es necesario modificarlos.
-- (Puedes copiar y pegar la sección de triggers de la respuesta anterior aquí)

-- 1. Trigger de validación: Asegurar que el salario de un empleado no sea negativo.
CREATE OR REPLACE TRIGGER trg_validar_salario_empleado
BEFORE INSERT OR UPDATE ON Empleados
FOR EACH ROW
BEGIN
    IF :NEW.salario < 350000 THEN
        :NEW.salario := 350000; -- Asigna un valor mínimo si no se cumple la regla
        DBMS_OUTPUT.PUT_LINE('Salario no válido, se asignó el mínimo de 350000.');
    END IF;
END;
/
-- Autor/a: [Tu Nombre Completo]

-- 2. Trigger de validación: Impedir que se programe una función en una sala ya ocupada en el mismo horario.
CREATE OR REPLACE TRIGGER trg_validar_horario_funcion
BEFORE INSERT ON Funciones
FOR EACH ROW
DECLARE
    v_count NUMBER;
BEGIN
    SELECT COUNT(*) INTO v_count
    FROM Funciones
    WHERE sala_id = :NEW.sala_id
    AND fecha = :NEW.fecha
    AND :NEW.hora_inicio < hora_fin AND :NEW.hora_fin > hora_inicio;

    IF v_count > 0 THEN
        RAISE_APPLICATION_ERROR(-20010, 'La sala ya está ocupada en ese horario.');
    END IF;
END;
/
-- Autor/a: [Tu Nombre Completo]

-- 3. Trigger de auditoría: Registrar cambios en la tabla Reserva.
CREATE OR REPLACE TRIGGER trg_auditar_reservas
AFTER INSERT OR UPDATE OR DELETE ON Reserva
FOR EACH ROW
DECLARE
    v_accion VARCHAR2(10);
    v_valores_anteriores VARCHAR2(500) := '';
BEGIN
    IF INSERTING THEN
        v_accion := 'INSERT';
    ELSIF UPDATING THEN
        v_accion := 'UPDATE';
        v_valores_anteriores := 'Asientos: ' || :OLD.asientos_reservados || ', Total: ' || :OLD.total_pago;
    ELSIF DELETING THEN
        v_accion := 'DELETE';
    END IF;

    INSERT INTO audit_reservas (accion, reserva_id, cliente_id, funcion_id, asientos_reservados, total_pago, usuario, fecha_auditoria, valores_anteriores)
    VALUES (
        v_accion,
        NVL(:NEW.reserva_id, :OLD.reserva_id),
        NVL(:NEW.cliente_id, :OLD.cliente_id),
        NVL(:NEW.funcion_id, :OLD.funcion_id),
        NVL(:NEW.asientos_reservados, :OLD.asientos_reservados),
        NVL(:NEW.total_pago, :OLD.total_pago),
        USER,
        SYSDATE,
        v_valores_anteriores
    );
END;
/
-- Autor/a: [Tu Nombre Completo]

-- 4. Trigger de auditoría: Registrar cambios en la tabla Empleados.
CREATE OR REPLACE TRIGGER trg_auditar_empleados
AFTER UPDATE OF salario ON Empleados
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('Auditoría: El salario del empleado ' || :OLD.empleado_id || ' cambió de ' || :OLD.salario || ' a ' || :NEW.salario);
END;
/
-- Autor/a: [Tu Nombre Completo]

-- 5. Trigger funcional: Actualizar la tabla de estadísticas de ocupación después de una reserva.
CREATE OR REPLACE TRIGGER trg_actualizar_estadisticas_ocupacion
AFTER INSERT ON Reserva
FOR EACH ROW
DECLARE
    v_sala_id NUMBER;
    v_fecha DATE;
    v_capacidad NUMBER;
    v_total_asientos_ocupados NUMBER;
    v_total_ingresos NUMBER;
BEGIN
    SELECT f.sala_id, f.fecha, s.capacidad
    INTO v_sala_id, v_fecha, v_capacidad
    FROM Funciones f
    JOIN Salas s ON f.sala_id = s.sala_id
    WHERE f.funcion_id = :NEW.funcion_id;

    SELECT NVL(SUM(r.asientos_reservados), 0), NVL(SUM(r.total_pago), 0)
    INTO v_total_asientos_ocupados, v_total_ingresos
    FROM Reserva r
    JOIN Funciones f ON r.funcion_id = f.funcion_id
    WHERE f.sala_id = v_sala_id AND f.fecha = v_fecha;

    MERGE INTO estadisticas_ocupacion eo
    USING (SELECT v_sala_id AS sala_id, v_fecha AS fecha FROM dual) src
    ON (eo.sala_id = src.sala_id AND eo.fecha = src.fecha)
    WHEN MATCHED THEN
        UPDATE SET
            asientos_ocupados = v_total_asientos_ocupados,
            ingresos_generados = v_total_ingresos,
            porcentaje_ocupacion = (v_total_asientos_ocupados / v_capacidad) * 100,
            ultima_actualizacion = SYSDATE
    WHEN NOT MATCHED THEN
        INSERT (sala_id, fecha, asientos_ocupados, porcentaje_ocupacion, ingresos_generados)
        VALUES (v_sala_id, v_fecha, :NEW.asientos_reservados, (:NEW.asientos_reservados / v_capacidad) * 100, :NEW.total_pago);
END;
/
-- Autor/a: [Tu Nombre Completo]

-- Fin del script de desarrollo PL/SQL